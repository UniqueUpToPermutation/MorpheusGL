#version 450 core

#define TEXTURE_ARRAY_SIZE 8

// Default group size
#ifndef GROUP_SIZE
#define GROUP_SIZE 32
#endif

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;

// Uniforms
layout(binding = 0) uniform samplerCube inputTexture;
layout(binding = 0) writeonly uniform imageCube outputTextures[TEXTURE_ARRAY_SIZE];

uniform uint outputTextureCount;
uniform uint totalLevels;
uniform uint beginLevel;

// Includes from other files
#pragma include "cubemap.glsl"
vec3 cubemapGetDirection(vec2 surfacePosition, uint face);

#pragma include "ggx.glsl"
vec3 ggxPrefilterEnvMap(samplerCube inTex, float Roughness, vec3 R);

vec2 getSurfacePosition(uvec2 texPosition, uint texSize) {
    vec2 uv = (vec2(texPosition) + 0.5) / float(texSize);
    return 2.0 * uv - 1.0;
}

void main() {
    uint face = gl_GlobalInvocationID.z;
    uvec2 pixLocation = gl_GlobalInvocationID.xy;

    uint size = imageSize(outputTextures[0]).x;
    int currentTextureIndex = 0;
	uint currentLevel = beginLevel;

    while (currentTextureIndex < outputTextureCount && 
		currentTextureIndex < TEXTURE_ARRAY_SIZE && 
		pixLocation.x < size && pixLocation.y < size) {
        vec2 surfacePos = getSurfacePosition(pixLocation, size);
        vec3 dir = cubemapGetDirection(surfacePos, face);

        float roughness = float(currentLevel) / float(totalLevels - 1);

        // Do Monte Carlo
        vec3 specular = ggxPrefilterEnvMap(inputTexture, roughness, dir);

        imageStore(outputTextures[currentTextureIndex], ivec3(gl_GlobalInvocationID), vec4(specular, 1.0));

        size = size / 2;
        currentTextureIndex++;
		currentLevel++;
    }
}