#version 450 core

#define FACE_POSITIVE_X 0
#define FACE_NEGATIVE_X 1
#define FACE_POSITIVE_Y 2
#define FACE_NEGATIVE_Y 3
#define FACE_POSITIVE_Z 4
#define FACE_NEGATIVE_Z 5

#define TEXTURE_ARRAY_SIZE 8

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

const float PI = 3.1415926535897932384626433832795;

const uint NumSamples = 1024;
const float InvNumSamples = 1.0 / float(NumSamples);

// Uniforms
layout(binding = 0) uniform samplerCube inputTexture;
layout(binding = 0) writeonly uniform imageCube outputTextures[TEXTURE_ARRAY_SIZE];

uniform uint outputTextureCount;
uniform uint totalLevels;
uniform uint beginLevel;

float radicalInverse_VdC(uint bits)
{
	bits = (bits << 16u) | (bits >> 16u);
	bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
	bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
	bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
	bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
	return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

// Sample i-th point from Hammersley point set of NumSamples points total.
vec2 hammersley(uint i)
{
	return vec2(i * InvNumSamples, radicalInverse_VdC(i));
}

vec3 importanceSampleGGX(vec2 Xi, float Roughness, vec3 N)
{
    float a = Roughness * Roughness;
    float Phi = 2 * PI * Xi.x;
    float CosTheta = sqrt( (1 - Xi.y) / ( 1 + (a*a - 1) * Xi.y ) );
    float SinTheta = sqrt( 1 - CosTheta * CosTheta );
    vec3 H;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;
    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);
    vec3 TangentX = normalize(cross(UpVector, N));
    vec3 TangentY = cross(N, TangentX);

    // Tangent to world space
    return TangentX * H.x + TangentY * H.y + N * H.z;
}

vec3 precomputeSpecular(float Roughness, vec3 N)
{
    // Assume the observer is looking directly at the surface (split-sum approx)
    vec3 V = N;
    vec3 SpecularLighting = vec3(0, 0, 0);
    for (uint i = 0; i < NumSamples; i++)
    {
        vec2 Xi = hammersley(i);
        vec3 H = importanceSampleGGX(Xi, Roughness, N);
        vec3 L = 2 * dot( V, H ) * H - V;

        float NoV = clamp(dot( N, V ), 0.0, 1.0);
        float NoL = clamp(dot( N, L ), 0.0, 1.0);
        float NoH = clamp(dot( N, H ), 0.0, 1.0);
        float VoH = clamp(dot( V, H ), 0.0, 1.0);

        if (NoL > 0)
        {
            vec3 SampleColor = textureLod(inputTexture, L, 0).rgb;
            SpecularLighting += SampleColor;
        }
    }
    return SpecularLighting / NumSamples;
}

vec3 getDirection(vec2 surfacePosition, uint face) {
    vec3 result;
    switch (face) {
        case FACE_POSITIVE_X:
            result.x = 1.0;
            result.z = -surfacePosition.x;
            result.y = -surfacePosition.y;
            break;
        case FACE_NEGATIVE_X:
            result.x = -1.0;
            result.z = surfacePosition.x;
            result.y = -surfacePosition.y;
            break;
        case FACE_POSITIVE_Y:
            result.x = surfacePosition.x;
            result.y = 1.0;
            result.z = surfacePosition.y;
            break;
        case FACE_NEGATIVE_Y:
            result.x = surfacePosition.x;
            result.y = -1.0;
            result.z = -surfacePosition.y;
            break;
        case FACE_POSITIVE_Z:
            result.x = surfacePosition.x;
            result.y = -surfacePosition.y;
            result.z = 1.0;
            break;
        case FACE_NEGATIVE_Z:
            result.x = -surfacePosition.x;
            result.y = -surfacePosition.y;
            result.z = -1.0;
            break;
    }
    return normalize(result);
}

vec2 getSurfacePosition(uvec2 texPosition, uint texSize) {
    vec2 uv = (vec2(texPosition) + 0.5) / float(texSize);
    return 2.0 * uv - 1.0;
}

void main() {
    uint face = gl_GlobalInvocationID.z;
    uvec2 pixLocation = gl_GlobalInvocationID.xy;

    uint size = imageSize(outputTextures[0]).x;
    int currentTextureIndex = 0;
	uint currentLevel = beginLevel;

    while (currentTextureIndex < outputTextureCount && pixLocation.x < size && pixLocation.y < size) {
        vec2 surfacePos = getSurfacePosition(pixLocation, size);
        vec3 dir = getDirection(surfacePos, face);

        float roughness = float(currentLevel) / float(totalLevels - 1);

        // Do Monte Carlo
        vec3 specular = precomputeSpecular(roughness, dir);

        imageStore(outputTextures[currentTextureIndex], ivec3(gl_GlobalInvocationID), vec4(specular, 1.0));

        size = size / 2;
        currentTextureIndex++;
		currentLevel++;
    }
}